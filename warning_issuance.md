###### Creates Polygon from lane offset information
```js
prevLat = intersectionCenterpointLat // from MAP
prevLon = intersectionCenterpointLon // from MAP
laneWidth = masterLaneWidth // from MAP

// sizeOfList is the size of the list of offsets (yAdj and xAdj)
for (i = 0, i < sizeOfList, i++){
	// When i = 0, nextLat and nextLon is the location of the stopbar along the lane centerline
	nextLat = prevLat + (yAdj(i)/100) / 111111
	nextLon = prevLon + (xAdj(i)/100) / (111111 * COS(prevLat * PI() / 180))
	laneWidth = laneWidth + laneWidthAdj(i)

	if (i < sizeOfList-1){
		bearing1 = ATAN(yAdj(i+1) / xAdj(i+1)) + PI()/2
		bearing2 = ATAN(yAdj(i+1) / xAdj(i+1)) - PI()/2
	}

	xAdjR = COS(bearing1) * (laneWidth/2)
	yAdjR = SIN(bearing1) * (laneWidth/2)
	xAdjL = COS(bearing2) * (laneWidth/2)
	yAdjL = SIN(bearing2) * (laneWidth/2)

	//LaneR/L represent lists of points making up the two sides of the lane
	laneR(i,0) = nextLat + (yAdjR/100) / 111111
	laneR(i,1) = nextLon + (xAdjR/100) / (111111 * COS(nextLat * PI() / 180))
	laneL(i,0) = nextLat + (yAdjL/100) / 111111
	laneL(i,1) = nextLon + (xAdjL/100) / (111111 * COS(nextLat * PI() / 180))
	if (i > 0){
		if (intersect(laneR(i-1,0),laneR(i-1,1),laneR(i,0),laneR(i,1),laneL(i-1,0),laneL(i-1,1),laneL(i,0),laneL(i,1))){
			temp1 = laneR(i,0)
			temp2 = laneR(i,1)
			laneR(i,0) = laneL(i,0)
			laneR(i,1) = laneL(i,1)
			laneL(i,0) = temp1
			laneL(i,1) = temp2
		}
	}

	prevLat = nextLat
	prevLon = nextLon
}

for (i = 0, i < sizeOfList, i++){
	polygonBoundary(i,0) = laneR(i,0)
	polygonBoundary(i,1) = laneR(i,1)
}

for (i = 0, i < sizeOfList, i++){
	polygonBoundary(sizeOfList + i, 0) = laneL(sizeOfList - 1 - i, 0)
	polygonBoundary(sizeOfList + i, 1) = laneL(sizeOfList - 1 - i, 1)
}
```
###### polygonBoundary contains the boundary points for a single lane.

###### determine if BSM point falls within polygonBoundary, and if so, determine if red light warning is issued
```js
if(pointInPolygon(BSM.latitude, BSM.longitude, polygonBoundary)){
	PRT = TBD  //use 2.5 for now
	criticalAccel1 = TBD  //use 10 for now
	criticalAccel2 = TBD  //use 10 for now
	speedMph = BSM.speed * 2.23694 / 50
	warnTime = 1 + 1.47 * speedMph / 20
	dToStopbar = haversine(BSM.Latitude,BSM.longitude,stopbarLatitude,stopbarLongitude)
	tToStopbar = dToStopbar / (speedMph * 1.47)

	criticalDist1 = 1.47 * speedMph * PRT + speedMph * speedMph / (2 * criticalAccel1)  // Use this equation for now. I need to reach out to Siemens on the accuracy of this equation.
	criticalDist2 = 1.47 * speedMph * PRT + speedMph * speedMph / (2 * criticalAccel2)  // Use this equation for now. I need to reach out to Siemens on the accuracy of this equation.

	// The SPAT message used for the equations and conditions below should be as close in time to the BSM as possible and all associated data should for the intersectionID/laneID (polygon boundary) that the BSM is in.	
	if ((SPAT.SignalState = 7 || SPAT.SignalState = 8) && (tToStopbar  > SPAT.timeNextphase))  ||  (SPAT.SignalState = 3 and (criticalDist1 > dToStopbar){
		conditionA = TRUE;
	}
	if ((tToStopbar < warnTime) && (criticalDist1 > dToStopbar)) ||  criticalDist2 > dToStopbar {
		conditionB = TRUE
	}
	redLightWarningEvent = FALSE;
	if conditionA && conditionB{
		redLightWarningEvent = TRUE:
	}
}
```

###### Function to calculate distance between two points in feet
```js
double haversine(lat1, lon1, lat2, lon2){

	lat1 = lat1 * 3.14159 / 180
	lon1 = lon1 * 3.14159 / 180
	lat2 = lat2 * 3.14159 / 180
	lon2 = lon2 * 3.14159 / 180
	dlon = (lon2 - lon1)
	dlat = (lat2 - lat1)

	a = Sin(dlat / 2) * Sin(dlat / 2) + Cos(lat1) * Cos(lat2) * Sin(dlon / 2) * Sin(dlon / 2)
	r = 2 * WorksheetFunction.Atan2((1 - a) ^ 0.5, a ^ 0.5)
	return r * 3959 * 5280
}
```

###### Function to determine if two lines intersect
```js
boolean intersect (rLat1, rLon1, rLat2, rLon2, lLat1, lLon1, lLat2, lLon2){

slopeR = (rLat2 - rlat1) / (rLon2 - rLon1)
slopeL = (lLat2 - llat1) / (lLon2 - lLon1)
interceptR = rLat2 - (slopeR * rLon2)
interceptL = lLat2 - (slopeL * lLon2)
xIntersect = (interceptL - interceptR) / (slopeR - slopeL)
if (xIntersect > rLon2 && xIntersect < rLon1 && xIntersect > lLon2 && xIntersect < lLon1){
	return true;
}
if (xIntersect < rLon2 && xIntersect > rLon1 && xIntersect < lLon2 && xIntersect > lLon1){
	return true;
}
if (xIntersect > rLon2 && xIntersect < rLon1 && xIntersect < lLon2 && xIntersect > lLon1){
	return true;
}
if (xIntersect < rLon2 && xIntersect > rLon1 && xIntersect > lLon2 && xIntersect < lLon1){
	return true;
}
return false;
}
```

###### Function to determine if a BSM falls within the polygon identified by polygonBoundary
```js
boolean pointInPolygon(latBSM, lonBSM, polygonBoundary){
	oddNodes = FALSE
	j = sizeOf(polygonBoundary) - 1

	For (i = 0, i < sizeOf(polygonBoundary), i++){
        	If (((polygonBoundary(i, 0) < latBSM && polygonBoundary(j, 0) >= latBSM) || (aXY(j, 2) < latBSM && aXY(i, 2) >= latBSM)) && (aXY(i, 1) <= latBSM || aXY(j, 1) <= lonBSM)){
            		oddNodes = oddNodes ^ (aXY(i, 1) + (latBSM - aXY(i, 2)) / (aXY(j, 2) - aXY(i, 2)) * (aXY(j, 1) - aXY(i, 1)) < lonBSM)   // ^ indicates exclusive or (XOR)
        	}
        j = i
	}
	return oddNodes
}
```

###### Determine if speeding in school zone
# sizeOfList is the size of the list of offsets (yAdj and xAdj)
```js
for (i = 0, i < sizeOfList, i++){
	polygonBoundary(i,0) = TIM.nodeLat(i)
	polygonBoundary(i,1) = TIM.nodeLon(i)
}
if(pointInPolygon(BSM.latitude, BSM.longitude, polygonBoundary)){
	if(BSM.speed > 447){         //447*(0.02m/s) = 20mph
		if (year == 2020){   
			schoolZoneStartTime = 1577836800 + TIM.startTime*60           	//1577836800 is epoch time (s) for 1/1/2020 0:00:00
		}
		if (year == 2021){   
			schoolZoneStartTime = 1609459200 + TIM.startTime*60		//1609459200 is epoch time (s) for 1/1/2021 0:00:00
		}

		if (BSM.timestamp > schoolZoneStartTime && BSM.timestamp < schoolZoneStartTime + durationTime*60){
			schoolZoneSpeedEvent = TRUE
		}
	}
}
```



 