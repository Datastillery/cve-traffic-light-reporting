import prestodb
from datetime import datetime

conn=prestodb.dbapi.connect(
    host='localhost',
    port=9000,
    user='python',
    catalog='hive',
    schema='default',
)
cur = conn.cursor()

source_table = 'smart_columbus_cve__captcha'
source_device = 'morse_sandylane_cvcp'

os_partition = '2020_12'
day = '1'

# Maximum difference in seconds between a BSM and its matching SPAT
message_time_tolerance = '0.05'

bsm_work_table = "cve_geo_bsm_python_scratch"
geo_match_table = "cve_geo_match_python_scratch"
map_work_table = "cve_geo_map_python_scratch"
spat_work_table = "cve_geo_spat_python_scratch"
final_work_table = "cve_geo_final_python_scratch"
warnings_table = "cve_warnings_python_scratch"

def run_and_save_query(cur, query, save_table):
    start = datetime.now()
    cur.execute(f'drop table if exists {save_table}')
    cur.fetchall()

    cur.execute(f'create table {save_table} as {query}')
    cur.fetchall()
    print(f'Phase time for {save_table}: {datetime.now()-start}')


geo_bsm_query = f"""
with bsm_subset as (
        select * from {source_table} 
        where os_partition = '{os_partition}' 
        and messagetype = 'BSM' 
        and day(from_iso8601_timestamp(timestamp)) = {day}
        and cast(json_extract_scalar(messagebody, '$.coreData.speed') as double) > 1
    ), 

    identified_locations as (
        select 
            cast(json_extract_scalar(messagebody, '$.coreData.lat') as double) / 10000000 as lat, 
            cast(json_extract_scalar(messagebody, '$.coreData.long') as double) / 10000000 as long,
            cast(json_extract_scalar(messagebody, '$.coreData.speed') as double) as speed, 
            json_extract_scalar(messagebody, '$.coreData.id') as id, 
            sourcedevice,
            timestamp
            from bsm_subset
    ),
    
    lane_subset as (select * from smart_columbus_cve__cve_lane_geometries 
        where ingressapproach = 'true' 
        and lanetype = 'vehicle'
    )

    SELECT il.lat, il.long, il.sourcedevice, il.speed, il.timestamp, geo.laneid, geo.front_lat, geo.front_lon, il.id FROM lane_subset geo 
      join identified_locations il 
          on geo.sourcedevice = il.sourcedevice 
          and ST_Contains(ST_GeometryFromText(geo.geometry), ST_Point(il.long, il.lat))
"""


bsm_to_spat_query = f"""
with bsms_unix as (
    select timestamp, to_unixtime(from_iso8601_timestamp(timestamp)) as unixtime, sourcedevice, laneid
    from {bsm_work_table}
),

spats_unix as (
    select timestamp, to_unixtime(from_iso8601_timestamp(timestamp)) as unixtime, sourcedevice
    from {source_table} where os_partition = '{os_partition}' and messagetype = 'SPAT' and day(from_iso8601_timestamp(timestamp)) = {day}
),

unix_join as (
    select bsms.timestamp as bsm_timestamp, spats.timestamp as spat_timestamp, spats.sourcedevice, bsms.laneid
    from spats_unix as spats join bsms_unix as bsms on bsms.sourcedevice = spats.sourcedevice and abs(bsms.unixtime - spats.unixtime) < {message_time_tolerance} 
),

deduped_unix_join as (
    select min(spat_timestamp) as spat_timestamp, bsm_timestamp, sourcedevice, laneid
    from unix_join group by bsm_timestamp, sourcedevice, laneid
)

select * from deduped_unix_join
"""


map_query = f"""
with latest_map as (SELECT arbitrary(messagebody) as messagebody, sourcedevice FROM {source_table} where os_partition = '{os_partition}' and messagetype = 'MAP' group by sourcedevice),

extracted_values as (
    select 
           json_extract(messageBody, '$.intersections[0].laneWidth') as laneWidth, 
           cast(json_extract_scalar(messageBody, '$.intersections[0].refPoint.lat') as double) / 10000000 as refLat, 
           cast(json_extract_scalar(messageBody, '$.intersections[0].refPoint.long') as double) / 10000000 as refLon,

           transform(
               cast(json_extract(messageBody, '$.intersections[0].laneSet') AS ARRAY<JSON>),
                 x -> element_at(transform(cast(JSON_EXTRACT(x, '$.nodeList[1]') as ARRAY<JSON>),
                   y -> cast(ROW(
                     JSON_EXTRACT_scalar(x, '$.laneID'), 
                     JSON_EXTRACT_scalar(x, '$.ingressApproach'),
                     cast(transform(cast(JSON_EXTRACT(x, '$.connectsTo') as ARRAY<JSON>), connection -> JSON_EXTRACT_SCALAR(connection, '$.signalGroup')) as ARRAY<VARCHAR>),  
                     JSON_EXTRACT_scalar(y, '$.delta[1].x'), 
                     JSON_EXTRACT_scalar(y, '$.delta[1].y'),
                     JSON_EXTRACT_scalar(x, '$.nodeList[1][1].delta[1].x'), 
                     JSON_EXTRACT_scalar(x, '$.nodeList[1][1].delta[1].y')
                     ) 
                  as ROW(laneID VARCHAR, ingressApproach VARCHAR, signals ARRAY<VARCHAR>, x DOUBLE, y DOUBLE, xOffset DOUBLE, yOffset DOUBLE))
                 ), 1)
            ) as deltas,
    * from latest_map
),
    
extracted_coordinates as (
select transform(deltas, x -> cast(ROW(
  x.laneID, 
  x.ingressApproach, 
  x.signals,
  refLat + (x.y / 100) / 111111, 
  refLon + (x.x / 100) / (111111 * COS(refLat * PI() / 180)),
  MOD(90 - ATAN2(x.yOffset * -1, x.xOffset * -1)*180/PI(),360)
  ) as ROW(laneID VARCHAR, ingressApproach VARCHAR, signals ARRAY<VARCHAR>, lat DOUBLE, lon DOUBLE, laneDirection DOUBLE))) as coordinates, 
  * from extracted_values
),

stop_points as (
    SELECT ingressApproach, sourcedevice, laneID, signals, lat, lon, CASE WHEN laneDirection < 0 THEN laneDirection + 360 else laneDirection END as laneDirection 
    FROM extracted_coordinates CROSS JOIN UNNEST(coordinates) AS t ( laneID, ingressApproach, signals, lat, lon, laneDirection) 
    where ingressApproach is not null
)

select * from stop_points
"""


spat_query = f"""
with spat_subset as (
    SELECT * FROM {source_table} where messagetype = 'SPAT' and timestamp in (select spat_timestamp from {geo_match_table}) 
),

signal_states as (
    select 
        sourcedevice, 
        timestamp, 
        transform(
            cast(json_extract(messagebody, '$.intersections[0].states') as ARRAY<JSON>), 
            x -> cast(
                    ROW(
                        json_extract(x, '$.signalGroup'), 
                        json_extract(x, '$["state-time-speed"][0].eventState'),
                        json_extract(x, '$["state-time-speed"][0].timing.minEndTime')
                    ) as ROW(signalGroup VARCHAR, state VARCHAR, minEndTime DOUBLE)
                 )
        ) as signalStates 
    from spat_subset
),

extracted_signal_states as (
    select sourceDevice, timestamp, signalGroup, state, minEndTime
    from signal_states CROSS JOIN UNNEST(signalStates) AS t ( signalGroup, state, minEndTime)
),

lane_signal_groups as (
    select laneID, lat, lon, signalGroup, laneDirection, sourcedevice
    from {map_work_table} CROSS JOIN UNNEST(signals) as t (signalGroup)
),

spat_states as (
    select state, timestamp, laneID, laneDirection, minEndTime, sourcedevice
    from lane_signal_groups join extracted_signal_states using (signalGroup, sourcedevice)
),

aggregated_states as (
    select array_agg(cast(ROW(state, minEndTime) as ROW(state VARCHAR, minEndTime DOUBLE))) as states, timestamp, laneID, laneDirection, sourcedevice from spat_states group by timestamp, laneID, laneDirection, sourcedevice
)

select * from aggregated_states
"""


final_query = f"""
select 
    bsms.lat, bsms.long, bsms.timestamp as bsm_timestamp, spat_lane_states.timestamp as spat_timestamp, bsms.id,
    states, dd.laneID, sp.signals, bsms.sourcedevice, bsms.front_lat, bsms.front_lon, bsms.speed * 2.23694 / 50 as speed,
    ST_Distance(
        to_spherical_geography(ST_Point(cast(bsms.front_lon as double), cast(bsms.front_lat as double))), 
        to_spherical_geography(ST_Point(bsms.long, bsms.lat))
    ) * 3.281 as distanceToStop
from {bsm_work_table} bsms
  join {geo_match_table} dd on bsms.timestamp = dd.bsm_timestamp and bsms.laneID = dd.laneID
  join {spat_work_table} spat_lane_states on spat_lane_states.timestamp = dd.spat_timestamp and spat_lane_states.laneID = dd.laneID and dd.sourcedevice = spat_lane_states.sourcedevice
  join {map_work_table} sp on sp.laneID = dd.laneID and sp.sourcedevice = dd.sourcedevice
"""


warning_issue_query = f"""
with parameters as (select *,
    all_match(states, state -> state.state = 'stop-And-Remain') as red_light,
    any_match(states, state -> state.state = 'permissive-clearance' or state.state = 'protected-clearance') as yellow_light,
    states[1].minEndTime as timeNextphase,
    2.5 as prt,
    10 as criticalAccel,
    1 + 1.47 * speed / 20 as warnTime,
    distanceToStop / (speed * 1.47) as timeToSB,
    MINUTE(from_iso8601_timestamp(spat_timestamp)) * 600 
    + second(from_iso8601_timestamp(spat_timestamp)) * 10
    + millisecond(from_iso8601_timestamp(spat_timestamp)) / 100 as spat_time_as_moh
from {final_work_table} where speed > 0),

critical_distance as (select *, 
    1.47 * speed * prt + speed * speed / (2 * criticalAccel) as criticalDist,
    (timeNextphase - spat_time_as_moh) / 10 as timeToNextPhase
from parameters),

looped_time_to_next_phase as (
    select *, 
        case when timeToNextPhase < -20 then timeToNextPhase + 3600 else timeToNextPhase end as adjtimeToNextPhase
    from critical_distance
),

both_conditions as (select *,
    case when ((yellow_light = true) and (timeToSB > adjtimeToNextPhase)) 
                or (red_light = true and criticalDist > distanceToStop) 
                then true else false end as conditionA,
    case when ((timeToSB < warnTime) and (criticalDist < distanceToStop)) 
                or criticalDist > distanceToStop 
                then true else false end as conditionB
from looped_time_to_next_phase)

select case when conditionb = true and conditiona = true then true else false end as warning_issued, * from both_conditions
"""

all_start=datetime.now()

# run_and_save_query(cur, geo_bsm_query, bsm_work_table)
# run_and_save_query(cur, bsm_to_spat_query, geo_match_table)
# run_and_save_query(cur, map_query, map_work_table)
run_and_save_query(cur, spat_query, spat_work_table)
run_and_save_query(cur, final_query, final_work_table)
run_and_save_query(cur, warning_issue_query, warnings_table)

print(f'Total time: {datetime.now()-all_start}')