import report_utilities as utils

from datetime import date

SOURCE_TABLE = 'smart_columbus_cve__captcha'


def run_preemption_report(cur, partition, target_table):
    preemption_query = f"""
    with parsed_ssms as (
        with ssms as (
        select * from {SOURCE_TABLE} where os_partition = '{partition}' and messagetype = 'SSM'
        ),
        extracted_ssms as (select 
            json_extract_scalar(messagebody, '$.status[0].sigStatus[0].requester.id[1]') as id,
            json_extract_scalar(messagebody, '$.status[0].sigStatus[0].requester.request') as requestid,
            json_extract_scalar(messagebody, '$.status[0].sigStatus[0].status') as status,
            json_extract_scalar(messagebody, '$.status[0].id.id') as intersectionid,
            timestamp,
            to_unixtime(from_iso8601_timestamp(timestamp)) as unixtime
        from ssms),
        status as (select min(timestamp) as timestamp, min(unixtime) as unixtime, status, id, intersectionid, requestid from extracted_ssms group by id, intersectionid, requestid, status),
        granted_rejected_status as (select * from status where status = 'granted' or status = 'rejected'),
        requested_status as (select * from status where status = 'requested'),
        processing_status as (select * from status where status = 'processing')

        select count(1) as count, array_agg((status, timestamp)) as lifecycle, max_by(status,timestamp) as final_status, id, intersectionid, requestid from status group by id, intersectionid, requestid
        ), parsed_srms as (
        with srms as (
        select * from {SOURCE_TABLE} where os_partition = '{partition}' and messagetype = 'SRM'
        ),
        extracted_srms as (select 
            json_extract_scalar(messagebody, '$.requestor.id[1]') as id,
            json_extract_scalar(messagebody, '$.requestor.type.role') as role,
            json_extract_scalar(messagebody, '$.requests[0].request.requestID') as requestid,
            json_extract_scalar(messagebody, '$.requests[0].request.requestType') as requesttype,
            json_extract_scalar(messagebody, '$.requests[0].request.id.id') as intersectionid,
            json_extract_scalar(messagebody, '$.requests[0].request.inBoundLane[1]') as inbound,
            json_extract_scalar(messagebody, '$.requests[0].request.outBoundLane[1]') as outbound,
            cast(json_extract_scalar(messagebody, '$.requestor.position.position.lat') as double) / 10000000 as lat,
            cast(json_extract_scalar(messagebody, '$.requestor.position.position.long') as double) / 10000000 as long,
            sourcedevice,
            timestamp,
            to_unixtime(from_iso8601_timestamp(timestamp)) as unixtime
        from srms)

        select timestamp, unixtime, lat, long, sourcedevice, id, intersectionid, requestid, requesttype, role, inbound, outbound from extracted_srms
        ),
        matched as (
        select 
            parsed_srms.id, parsed_srms.requestid, parsed_srms.intersectionid, final_status, lifecycle,
            role, requesttype, inbound, outbound, lat, long,
            parsed_srms.timestamp as srm_timestamp
        from parsed_srms join parsed_ssms
        on  parsed_srms.intersectionid = parsed_ssms.intersectionid 
        and parsed_srms.id = parsed_ssms.id 
        and parsed_srms.requestid = parsed_ssms.requestid),

        aggregated as (
            select 
                id,
                requestid,
                final_status,
                lifecycle as status_lifecycle,
                intersectionid,
                role,
                inbound,
                outbound,
                min(srm_timestamp) as initial_request_time,
                array_agg((lat, long, srm_timestamp, requesttype)) as requests
            from matched
                group by id,
                requestid,
                final_status,
                lifecycle,
                intersectionid,
                role,
                inbound,
                outbound
        )

        select
            id,
            requestid,
            final_status,
            cast(status_lifecycle as array(ROW(status varchar, timestamp varchar))) as status_lifecycle,
            intersectionid,
            role,
            inbound,
            outbound,
            initial_request_time,
            cast(requests as array(ROW(lat double, long double, srm_timestamp varchar, requesttype varchar))) as requests
        from aggregated
    """

    utils.run_and_save_query(cur, preemption_query, target_table)

cur = utils.new_connection()

for partition in utils.partitions_in_range(date(2020, 10, 16), date.today()):
    run_preemption_report(cur, partition, f"cve_preemption_{partition}")