import prestodb
from datetime import datetime

# Defines a single day of data to work with
os_partition = '2021_01'
day = '11'

# Maximum distance in ? from a stop bar for a BSM to be associated with it
distance_threshold = '0.00002'

# Maximum deviance in degrees from the lane's heading for a vehicle to be considered in that lane.
heading_tolerance = '20'

# Minimum speed in ? for a BSM to be included
speed_tolerance = '1.0'

# Maximum difference in seconds between a BSM and its matching SPAT
message_time_tolerance = '0.05'

source_table = 'smart_columbus_cve__captcha'

conn=prestodb.dbapi.connect(
    host='localhost',
    port=9000,
    user='python',
    catalog='hive',
    schema='default',
)
cur = conn.cursor()

def latest_maps(cur):
    map_query = f"""
    with latest_timestamp as (SELECT max(timestamp) as timestamp, sourcedevice FROM {source_table} where os_partition = '{os_partition}' and messagetype = 'MAP' group by sourcedevice),
    map_subset as (select * from {source_table} where os_partition = '{os_partition}' and messagetype = 'MAP' order by timestamp desc limit 500),
    latest_map as (select * from latest_timestamp join map_subset using (timestamp, sourcedevice)),

    extracted_values as (
        select 
            json_extract(messageBody, '$.intersections[0].laneWidth') as laneWidth, 
            cast(json_extract_scalar(messageBody, '$.intersections[0].refPoint.lat') as double) / 10000000 as refLat, 
            cast(json_extract_scalar(messageBody, '$.intersections[0].refPoint.long') as double) / 10000000 as refLon,

            transform(
                cast(json_extract(messageBody, '$.intersections[0].laneSet') AS ARRAY<JSON>),
                    x -> element_at(transform(cast(JSON_EXTRACT(x, '$.nodeList[1]') as ARRAY<JSON>),
                    y -> cast(ROW(
                        JSON_EXTRACT_scalar(x, '$.laneID'), 
                        JSON_EXTRACT_scalar(x, '$.ingressApproach'),
                        cast(transform(cast(JSON_EXTRACT(x, '$.connectsTo') as ARRAY<JSON>), connection -> JSON_EXTRACT_SCALAR(connection, '$.signalGroup')) as ARRAY<VARCHAR>),  
                        JSON_EXTRACT_scalar(y, '$.delta[1].x'), 
                        JSON_EXTRACT_scalar(y, '$.delta[1].y'),
                        JSON_EXTRACT_scalar(x, '$.nodeList[1][1].delta[1].x'), 
                        JSON_EXTRACT_scalar(x, '$.nodeList[1][1].delta[1].y')
                        ) 
                    as ROW(laneID VARCHAR, ingressApproach VARCHAR, signals ARRAY<VARCHAR>, x DOUBLE, y DOUBLE, xOffset DOUBLE, yOffset DOUBLE))
                    ), 1)
                ) as deltas,
        * from latest_map
    ),
        
    extracted_coordinates as (
    select transform(deltas, x -> cast(ROW(
    x.laneID, 
    x.ingressApproach, 
    x.signals,
    refLat + (x.y / 100) / 111111, 
    refLon + (x.x / 100) / (111111 * COS(refLat * PI() / 180)),
    MOD(90 - ATAN2(x.yOffset * -1, x.xOffset * -1)*180/PI(),360)
    ) as ROW(laneID VARCHAR, ingressApproach VARCHAR, signals ARRAY<VARCHAR>, lat DOUBLE, lon DOUBLE, laneDirection DOUBLE))) as coordinates, 
    * from extracted_values
    ),

    stop_points as (
        SELECT ingressApproach, sourcedevice, laneID, signals, lat, lon, CASE WHEN laneDirection < 0 THEN laneDirection + 360 else laneDirection END as laneDirection 
        FROM extracted_coordinates CROSS JOIN UNNEST(coordinates) AS t ( laneID, ingressApproach, signals, lat, lon, laneDirection) 
        where ingressApproach is not null
    )

    select * from stop_points
    """

    map_work_table = "cve_map_python_scratch"

    cur.execute(f'drop table if exists {map_work_table}')
    cur.fetchall()

    cur.execute(f'create table {map_work_table} as {map_query}')
    cur.fetchall()

    return map_work_table


def bsms_in_stop_bars(cur, map_work_table):
    bsm_query = f"""
    with bsm_subset as (
        select * from {source_table} 
        where os_partition = '{os_partition}' 
        and messagetype = 'BSM' 
        and day(from_iso8601_timestamp(timestamp)) = {day}
    ), 

    identified_locations as (
        select 
            cast(json_extract_scalar(messagebody, '$.coreData.lat') as double) / 10000000 as lat, 
            cast(json_extract_scalar(messagebody, '$.coreData.long') as double) / 10000000 as long, 
            json_extract_scalar(messagebody, '$.coreData.id') as id, 
            sourcedevice,
            timestamp, 
            cast(json_extract_scalar(messagebody, '$.coreData.speed') as double) as speed, 
            cast(json_extract(messagebody,'$.coreData.heading') as double) / 80 as heading 
            from bsm_subset
    ),

    bsms_in_range as (
        select il.lat, il.long, il.id, il.timestamp, il.speed, il.heading, il.sourcedevice
        from identified_locations il join {map_work_table} sp on ST_Distance(ST_Point(il.lat, il.long), ST_Point(sp.lat, sp.lon)) < {distance_threshold}
        and il.sourcedevice = sp.sourcedevice
    ),

    distance_to_lane as (
        select 
            bsm.id, bsm.lat, bsm.long, laneID, timestamp, speed, sp.laneDirection, heading, bsm.sourcedevice,
            ST_Distance(ST_Point(bsm.lat, bsm.long), ST_Point(sp.lat, sp.lon)) as distance 
        from bsms_in_range bsm join {map_work_table} sp on 1=1
    ),

    bsms as (
        select id, min(distance) as distance, laneID, lat, long, timestamp, speed, laneDirection, heading, sourcedevice
        from distance_to_lane 
        where speed > {speed_tolerance} 
        and (
        (abs(heading - lanedirection) < {heading_tolerance}) 
        OR (heading > 360 - {heading_tolerance} AND heading > laneDirection + 360 - {heading_tolerance})
        OR (heading < {heading_tolerance} AND heading < laneDirection - 360 + {heading_tolerance})
        ) 
        and distance < {distance_threshold} 
        group by id, laneID, lat, long, timestamp, speed, laneDirection, heading, sourcedevice
    )

    select * from bsms
    """

    bsm_work_table = "cve_bsm_python_scratch"

    cur.execute(f'drop table if exists {bsm_work_table}')
    cur.fetchall()

    cur.execute(f'create table {bsm_work_table} as {bsm_query}')
    cur.fetchall()

    return bsm_work_table


def bsm_spat_map(cur, bsm_work_table):
    bsm_to_spat_query = f"""
    with bsms_unix as (
        select timestamp, to_unixtime(from_iso8601_timestamp(timestamp)) as unixtime, sourcedevice, laneid
        from {bsm_work_table}
    ),

    spats_unix as (
        select timestamp, to_unixtime(from_iso8601_timestamp(timestamp)) as unixtime, sourcedevice
        from {source_table} where os_partition = '{os_partition}' and messagetype = 'SPAT' and day(from_iso8601_timestamp(timestamp)) = {day}
    ),

    unix_join as (
        select bsms.timestamp as bsm_timestamp, spats.timestamp as spat_timestamp, spats.sourcedevice, bsms.laneid
        from bsms_unix as bsms join spats_unix as spats on abs(bsms.unixtime - spats.unixtime) < {message_time_tolerance} and bsms.sourcedevice = spats.sourcedevice
    ),

    deduped_unix_join as (
        select min(spat_timestamp) as spat_timestamp, bsm_timestamp, sourcedevice, laneid
        from unix_join group by bsm_timestamp, sourcedevice, laneid
    )

    select * from deduped_unix_join
    """

    match_table = "cve_match_python_scratch"

    cur.execute(f'drop table if exists {match_table}')
    cur.fetchall()

    cur.execute(f'create table {match_table} as {bsm_to_spat_query}')
    cur.fetchall()

    return match_table


def spat_lane_state(cur, match_table, map_work_table):
    spat_query = f"""
    with spat_subset as (
        SELECT * FROM {source_table} 
        where messagetype = 'SPAT' and os_partition = '{os_partition}' 
        and day(from_iso8601_timestamp(timestamp)) = {day}
        and timestamp in (select spat_timestamp from {match_table}) 
    ),

    signal_states as (
        select 
            sourcedevice, 
            timestamp, 
            transform(
                cast(json_extract(messagebody, '$.intersections[0].states') as ARRAY<JSON>), 
                x -> cast(
                        ROW(
                            json_extract(x, '$.signalGroup'), 
                            json_extract(x, '$["state-time-speed"][0].eventState')
                        ) as ROW(signalGroup VARCHAR, state VARCHAR)
                    )
            ) as signalStates 
        from spat_subset
    ),

    extracted_signal_states as (
        select sourceDevice, timestamp, signalGroup, state 
        from signal_states CROSS JOIN UNNEST(signalStates) AS t ( signalGroup, state)
    ),

    lane_signal_groups as (
        select laneID, lat, lon, signalGroup, laneDirection, sourcedevice
        from {map_work_table} CROSS JOIN UNNEST(signals) as t (signalGroup)
    ),

    spat_states as (
        select state, timestamp, laneID, laneDirection 
        from lane_signal_groups join extracted_signal_states using (signalGroup, sourcedevice)
    ),

    spat_truthy_states as (
        select state = 'stop-And-Remain' as signal_group_red, timestamp, laneID, laneDirection 
        from spat_states
    ),

    spat_lane_states as (
        select every(signal_group_red) as lane_red_light, laneID, laneDirection, timestamp 
        from spat_truthy_states group by laneID, timestamp, laneDirection
    )

    select * from spat_lane_states
    """

    spat_work_table = "cve_spat_python_scratch"

    cur.execute(f'drop table if exists {spat_work_table}')
    cur.fetchall()

    cur.execute(f'create table {spat_work_table} as {spat_query}')
    cur.fetchall()

    return spat_work_table


def final_join(cur, bsm_work_table, match_table, spat_work_table, map_work_table):
    final_query = f"""
    --- Final Result

    select 
        bsms.id, bsms.lat, bsms.long, bsms.timestamp as bsm_timestamp, spat_lane_states.timestamp as spat_timestamp, 
        lane_red_light, dd.laneID, sp.signals, bsms.laneDirection, bsms.heading, bsms.sourcedevice
    from {bsm_work_table} bsms
    join {match_table} dd on bsms.timestamp = dd.bsm_timestamp and bsms.laneID = dd.laneID
    join {spat_work_table} spat_lane_states on spat_lane_states.timestamp = dd.spat_timestamp and spat_lane_states.laneID = dd.laneID
    join {map_work_table} sp on sp.laneID = dd.laneID
    """

    final_work_table = "cve_final_python_scratch"

    cur.execute(f'drop table if exists {final_work_table}')
    cur.fetchall()

    cur.execute(f'create table {final_work_table} as {final_query}')
    cur.fetchall()

    return final_work_table

all_start=datetime.now()

print('Getting latest MAPs')
start = datetime.now()
maps = latest_maps(cur)
print(f'Phase time: {datetime.now()-start}')

print('Getting BSMs in latest stop bars')
start = datetime.now()
bsms = bsms_in_stop_bars(cur, maps)
print(f'Phase time: {datetime.now()-start}')

print('Matching BSMs to SPATs')
start = datetime.now()
bsm_spat_map = bsm_spat_map(cur, bsms)
print(f'Phase time: {datetime.now()-start}')

print('Getting lane state from SPATs')
start = datetime.now()
spats = spat_lane_state(cur, bsm_spat_map, maps)
print(f'Phase time: {datetime.now()-start}')

print('Building final join')
start = datetime.now()
final_join(cur, bsms, bsm_spat_map, spats, maps)
print(f'Phase time: {datetime.now()-start}')

print(f'Total time: {datetime.now()-all_start}')